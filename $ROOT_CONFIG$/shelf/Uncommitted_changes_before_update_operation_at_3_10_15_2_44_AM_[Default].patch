Index: instance.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- instance.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ instance.py	(revision )
@@ -1,5 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+
+
 __author__ = 'wadda'
 # Pinched 2014
 # Created and re-created many times by a lot of different people over the last 14 years.
@@ -9,10 +11,10 @@
 from tempfile import gettempdir
 
 
-class singleInstance(object):
+class SingleInstance(object):
     def __init__(self):
         self.lockfile = os.path.normpath(gettempdir() + '/' + 'wadda.lock')
-        print self.lockfile
+        print((self.lockfile))
         self.single = True
         import fcntl
 
@@ -24,13 +26,13 @@
             self.single = False
             sys.exit('NxGPS is already running')
 
-
 if __name__ == '__main__':
     from time import sleep
 
-    lock = singleInstance()
+    lock = SingleInstance()
     if lock.single:
-        print 'single instance... running'
+        print('single instance... running')
         sleep(30)
+
     else:
-        print 'another instance is running... quitting'
+        print('another instance is running... quitting')
Index: gpsclient.py
===================================================================
--- gpsclient.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ gpsclient.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
@@ -1,132 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""GPSD client to connect, read, and create gps attributes"""
-
-from gps import time, gps, gpsdata
-import socket
-import sys
-import threading
-from pubsub import pub
-
-
-class GpsClient(threading.Thread):
-    """ Connects to GPSD. Publishes streamed data until it dies."""
-
-    def __init__(self):
-        try:
-            threading.Thread.__init__(self)
-            # noinspection PyCallingNonCallable
-            self.gpsd = gps(mode=0x000001)  # starting the stream of info
-            self.running = False
-        except socket.error as error:  # TODO: keep alive for reconnection
-            print "GPSD ERROR CHECK GPS CONNECTION\n" * 5
-            print 'This is what happened...'
-            print error
-            sys.exit()
-
-    def run(self):
-        self.running = True
-        while self.running:
-            # grab EACH set of gpsd info to clear the buffer
-            self.gpsd.next()
-
-    def stopclient(self):
-        """Stops Client"""
-        self.running = False
-
-    @property
-    def fix(self):
-        """Creates instance attributes
-        gpsdata.fix.altitude   # 41.9 (meters)
-        gpsdata.fix.climb      # 0.1 (m/s) ## Error Estimates 95% confidence
-        gpsdata.fix.epc        # nan (not a number) Climb/sink error estimate m/s
-        gpsdata.fix.epd        # nan (cheap gps) Direction error estimate
-        gpsdata.fix.eps        # 6.12 (m/s) Speed error estimate
-        gpsdata.fix.ept        # 0.005 (seconds) Time error estimate
-        gpsdata.fix.epv        # 5.175 (meters) Vertical error estimate
-        gpsdata.fix.epx        # 2.345 (meters) Latitude error estimate
-        gpsdata.fix.epy        # 3.456 (meters) Longitude error estimate
-        gpsdata.fix.latitude   # -33.123456789
-        gpsdata.fix.longitude  # 151.123456789
-        gpsdata.fix.mode       # 1|2|3 (1:no fix; 2:2D; 3:3D)
-        gpsdata.fix.speed      # 0.123 (m/s)
-        gpsdata.fix.time       # u'2013-12-16T05:40:44.000Z'| 1387172437.0 (epoch)
-        gpsdata.fix.track      # 203.45 (degrees True North)
-        """
-        return self.gpsd.fix
-
-    @property
-    def utc(self):
-        """Creates instance attribute data.utc # u'2013-12-16T05:40:44.000Z'"""
-        # pub.sendMessage('utc',data=Gpsclient.utc)
-        return self.gpsd.utc
-
-    @property
-    def satellites(self):
-        """Creates instance tuple gpsdata.satellites # (8, 12) 8 satellites used 12 in view"""
-        return self.gpsd.satellites_used, len(self.gpsd.satellites)  # _used
-
-
-def senddata():
-    """ Send the following chunks """
-
-    pub.sendMessage('utc',
-                    utc=data.utc)
-
-    pub.sendMessage('lat_lon',
-                    lat=data.fix.latitude,
-                    lon=data.fix.longitude)
-
-    pub.sendMessage('speed_track',
-                    sog=data.fix.speed,
-                    cog=data.fix.track)
-
-    pub.sendMessage('satstats',
-                    mode=data.fix.mode,
-                    usedinview=data.satellites)
-    time.sleep(.95)
-
-
-data = GpsClient()
-data.start()
-
-if __name__ == '__main__':
-    import os
-
-    gpsdata = GpsClient()
-    try:
-        # start client
-        gpsdata.start()
-        while True:
-            os.system('clear')  # clear the terminal (optional)
-            print "latitude ", gpsdata.fix.latitude
-            print "longitude ", gpsdata.fix.longitude
-            print "UTC & time ", gpsdata.utc, ' ', gpsdata.fix.time
-            print "altitude (m)", gpsdata.fix.altitude
-            print "eps ", gpsdata.fix.eps
-            print "epx ", gpsdata.fix.epx
-            print "epv ", gpsdata.fix.epv
-            print "ept ", gpsdata.gpsd.fix.ept
-            print "speed (m/s) ", gpsdata.fix.speed
-            print "climb (m/s)", gpsdata.fix.climb
-            print "track ", gpsdata.fix.track
-            print "mode ", gpsdata.fix.mode
-            print "sats ", gpsdata.satellites
-            time.sleep(.9)
-
-    # Ctrl C
-    except KeyboardInterrupt:
-        print "User cancelled"
-
-    # Error
-    except:
-        print "Unexpected error:", sys.exc_info()[0]
-        raise
-
-    finally:
-        print "Stopping gps client"
-        gpsdata.stopclient()
-        # wait for the tread to finish
-        gpsdata.join()
-
-    print "Done"
Index: latlon.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- latlon.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ latlon.py	(revision )
@@ -2,141 +2,89 @@
 # -*- coding: utf-8 -*-
 
 """Deals with Lat Lon stuff"""
-from math import modf, radians
-import gps3
-import geomag
-import control
-from odometer import odometer
-from waypoint import waypoint
+from math import modf
 
-settings = control.settings
-units = control.units
+latitude = {}
+longitude = {}
 
 
-class DoLatLon(object):
-
-    def __init__(self):
-        """ do_lat_lon creates lat/lon attributes
+def dms(lat, lon, form='DMM'):
-        """
+    """
-        self.lat = None
-        self.lon = None
+    Arguments:
+        :param lat: (float), -15.560615 (negative = South)
+        :param lon: (float), -146.241122 (negative = West)  # Apataki Carenage
+        :param form: (str), 'DDD', 'DMM', 'DMS' Degrees, Minutes, Seconds
+    Returns:
+        course: (dict) e.g.,
 
-    def do_lat_lon(self, lat, lon):
-        """banana
-        """
+    """
-        if isinstance(gps3.Fix.TPV['lat'], str):  # One is not without the other...unless it's severely broken.
-            self.lat = self.lon = None
-            return
+    if not isinstance(lat and lon, float):
+        print('one or both latitude or longitude is/are not floats/integers')
+        return None
 
-        self.lat = round(gps3.Fix.TPV['lat'], 6)  # 6 is enough
-        self.lon = round(gps3.Fix.TPV['lon'], 6)
-        self.showlatlon()
-        odometer.do_odometer(self.lat, self.lon)
-        if settings.startpoint_lat is None:
-            settings.startpoint_lat = self.lat
-            settings.startpoint_lon = self.lon
-            waypoint.do_bearing_distance(self.lat, self.lon)
-            return
+    global latitude, longitude
+    latitude = {'raw': round(lat, 6)}  # 6 is enough
+    longitude = {'raw': round(lon, 6)}
 
-        else:
-            waypoint.do_bearing_distance(self.lat, self.lon)
-        return
-
-    def showlatlon(self):
-        """
-        returns string in fmt DDD or DMM or DMS
-        having been rounded to less than 1 foot @ equator
-        """
-        pretty_lat = pretty_lon = None
-        if not settings.show_latlon:
-            return
-
-        if self.lat is None:
-            pretty_lat = pretty_lon = "No Data"
-            print('No_Lat:', pretty_lat, ' No_Lon:', pretty_lon)
-
-        if settings.latlon_units == 'DDD':
+    if form == 'DDD':
-            # Latitude
+        # Latitude
-            _lat = abs(self.lat)
-            if self.lat > 0.0:
-                pretty_lat = '{0:3.6f}° N'.format(_lat)
+        if lat > 0.0:
+            latitude['DDD'] = '{0:3.6f}° N'.format(lat)
-            else:
+        else:
-                pretty_lat = '{0:3.6f}° S'.format(_lat)
+            _lat = abs(lat)
+            latitude['DDD'] = '{0:3.6f}° S'.format(_lat)
 
-            # Longitude
+        # Longitude
-            _lon = abs(self.lon)
-            if self.lon > 0.0:
-                pretty_lon = '{0:3.6f}° E'.format(_lon)
+        if lon > 0.0:
+            longitude['DDD'] = '{0:3.6f}° E'.format(lon)
-            else:
+        else:
-                pretty_lon = '{0:3.6f}° W'.format(_lon)
+            _lon = abs(lon)
+            longitude['DDD'] = '{0:3.6f}° W'.format(_lon)
 
-        if settings.latlon_units == 'DMM':
+    if form == 'DMM':
-            # Latitude
+        # Latitude
-            _lat = abs(self.lat)
+        _lat = abs(lat)
-            minlat, deglat = modf(_lat)
-            minlat *= 60
+        minlat, deglat = modf(_lat)
+        minlat *= 60
-            if self.lat > 0.0:
-                pretty_lat = '{0}° {1:2.5f}\' N'.format(int(deglat), minlat)
+        if lat > 0.0:
+            latitude['DMM'] = '{0}° {1:2.5f}\' N'.format(int(deglat), minlat)
-            else:
+        else:
-                pretty_lat = '{0}° {1:2.5f}\' S'.format(int(deglat), minlat)
+            latitude['DMM'] = '{0}° {1:2.5f}\' S'.format(int(deglat), minlat)
 
-            # Longitude
+        # Longitude
-            _lon = abs(self.lon)
+        _lon = abs(lon)
-            minlon, deglon = modf(_lon)
-            minlon *= 60
+        minlon, deglon = modf(_lon)
+        minlon *= 60
-            if self.lon > 0.0:
-                pretty_lon = '{0}° {1:2.4f}\' E'.format(int(deglon), minlon)
+        if lon > 0.0:
+            longitude['DMM'] = '{0}° {1:2.4f}\' E'.format(int(deglon), minlon)
-            else:
+        else:
-                pretty_lon = '{0}° {1:2.4f}\' W'.format(int(deglon), minlon)
+            longitude['DMM'] = '{0}° {1:2.4f}\' W'.format(int(deglon), minlon)
 
-        if settings.latlon_units == 'DMS':
+    if form == 'DMS':
-            # Latitude
+        # Latitude
-            _lat = abs(self.lat)
-            mmm, deglat = modf(_lat)
-            sec, minlat = modf(mmm * 60)
+        _lat = abs(lat)
+        minlat, deglat = modf(_lat)
+        sec, minutelat = modf(minlat * 60)
-            sec *= 60.0
+        sec *= 60.0
-            if self.lat > 0.0:
-                pretty_lat = '{0}° {1}\' {2:2.3f}\" N'.format(int(deglat), int(minlat), sec)
+        if lat > 0.0:
+            latitude['DMS'] = '{0}° {1}\' {2:2.3f}\" N'.format(int(deglat), int(minutelat), sec)
-            else:
+        else:
-                pretty_lat = '{0}° {1}\' {2:2.3f}\" S'.format(int(deglat), int(minlat), sec)
+            latitude['DMS'] = '{0}° {1}\' {2:2.3f}\" S'.format(int(deglat), int(minutelat), sec)
 
-            # Longitude
+        # Longitude
-            _lon = abs(self.lon)
+        _lon = abs(lon)
-            mmm, deglon = modf(_lon)
-            sec, minlon = modf(mmm * 60)
-            sec *= 60.0
+        mmm, deglon = modf(_lon)
+        sec, minlon = modf(mmm * 60)
+        sec *= 60.0
-            if self.lon > 0.0:
-                pretty_lon = '{0}° {1}\' {2:2.3f}\" E'.format(int(deglon), int(minlon), sec)
+        if lon > 0.0:
+            longitude['DMS'] = '{0}° {1}\' {2:2.3f}\" E'.format(int(deglon), int(minlon), sec)
-            else:
+        else:
-                pretty_lon = '{0}° {1}\' {2:2.3f}\" W'.format(int(deglat), int(minlon), sec)
+            longitude['DMS'] = '{0}° {1}\' {2:2.3f}\" W'.format(int(deglon), int(minlon), sec)
+        for key in latitude:
+            print('Latitude:',latitude[key])
+        for key in longitude:
+            print('Longitude:',longitude[key])
 
-        # pub.sendMessage('show_latlon', show_lat=pretty_lat, show_lon=pretty_lon)
-        print('Latitude: ', pretty_lat, ' Lon: ', pretty_lon)  # Test
-        return
+    # print('Latitude: ', latitude, ' Longitude: ', longitude)  # Test
+    return latitude, longitude
 
-    def magdec(self):
-        """
-        Magnetic Declination to write magdec to settings
-        Called with every configuration file write and every 24 hours of continous operation
-        """
-        if settings.true_or_magnetic is True:
-            settings.magnetic_declination = 0.0  # Declination in radians)
-            settings.magnetic_declination_degrees = 0.0
-            return
-
-        if self.lat:  # That is, if there's latitude and longitude
-            try:
-                magnetic_declination_degrees = geomag.declination(self.lat, self.lon)
-                mag_dec_radians = radians(magnetic_declination_degrees)  # radians
-                settings.magnetic_declination = mag_dec_radians
-                settings.magnetic_declination_degrees = magnetic_declination_degrees
-                settings.write_configuration()
-
-            except Exception as error:
-                print('Magnetic Declination is sick: ', error)
-                settings.magnetic_declination = 0.0
-                settings.true_or_magnetic = True
-        return
-
-
-do_latlon = DoLatLon()
Index: waypoint.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- waypoint.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ waypoint.py	(revision )
@@ -9,7 +9,7 @@
 from pyproj import Geod  # sudo pip3 install pyproj
 from cmath import asin, sin
 import math
-# from math import radians, degrees
+from math import radians, degrees, cos
 # import gps3
 
 CONVERSION = {'imperial': 1609.344,
@@ -20,7 +20,7 @@
 
 EARTH_RADIUS = 6371009.0  # meters...It's a mean radius, but nice enough for crosstrack calculations
 
-geoid = Geod(ellps='WGS84')
+geoid = Geod(ellps='WGS84')  # See pyproj documentation for other fun options
 start_reference = ()
 endpoint = ()
 
@@ -101,6 +101,7 @@
 
         bearing_to, _, trip_distance = odometer(start, current)  # Distance A to C in meters
         a2c_radians = math.radians(bearing_to)  # radians are required in crosstrack calculations
+
         # Crosstrack calculations in radians, output as a complex numbers {'meters': (281.8893996162284+0j)
         crosstrack_distance['meters'] = (asin(sin(trip_distance['meters']) * sin(a2c_radians - a2b_radians))
                                          * EARTH_RADIUS)
@@ -112,7 +113,7 @@
         print("Can't calculate crosstrack because:", error)
         return None
 
-    distance = {k: v.real for k, v in crosstrack_distance.items()}  # extract 'real' number
+    distance = {unit: v.real for unit, v in crosstrack_distance.items()}  # extract 'real' number
 
     # Printing for testing
     print("ATCF Trip distance:", trip_distance)  # TODO: What to do with trip_distance?
@@ -123,50 +124,72 @@
     return distance
 
 
+class BestScenario(object):
-""" Hypothetical 'if' calculations for speculation, fairy tales, and general BS
-deceptively based on a few 'real world' inputs.  Variations on a theme requiring
-current position
+    """ Hypothetical 'if' calculations for speculation, fairy tales, and general BS
+    deceptively based on a few 'real world' inputs.  Variations on a theme requiring
+    current position
-current time
-current speed
-current course
+    current speed
+    current course
+    current time
-waypoint, distance and bearing
-"""
+    waypoint, distance and bearing
+    """
 
-
 def closest_approach():
     """ Present course will pass X distance from waypoint,
     or course required to maintain minimum distance  (inverse crosstrack)
+
+    hyp(distance_to) cos(avoid_distance)
+
     current position
     waypoint
     """
     raise NotImplementedError
 
 
-def eta():
-    """ ETA given present course and speed
-    waypoint distance and bearing
-    current speed
+def vmg():
+    """ Velocity Made Good given present course and speed
+    waypoint bearing
     current course
-    current time
+    current speed
     """
     raise NotImplementedError
 
 
-def shortest():
+
+
+def shortest(current, cog, end=None, units='meters'):
     """ Shortest distance to waypoint given present course
     waypoint distance and bearing
     current course
     """
-    raise NotImplementedError
+    distance_with_course = {}
 
+    try:
+        if not end:
+           end, _ = DEFAULT_START  # Picks Apataki
+        global endpoint
+        endpoint = end
+        bearing_to, bearing_fro, distance = odometer(current, end)  # Bearings, Distance C to D in meters
 
-def vmg():
-    """ Velocity Made Good given present course and speed
-    waypoint bearing
-    current course
-    current speed
-    """
-    raise NotImplementedError
+        c2d_radians = radians(bearing_to)
+        cog_radians = radians(cog)
+        course_delta = abs(cog_radians - c2d_radians)  # TODO: Is abs() required/desired?
+
+        distance_with_course['meters'] = (cos(course_delta) + sin(course_delta)) * distance['meters']
+
+        if units != 'meters':
+            shortest_distance[units] = distance_with_course['meters'] / CONVERSION[units]
+            trip_distance[units] = trip_distance['meters'] / CONVERSION[units]
+
+    except Exception as error:
+        print("Shortest distance cannot be calculated because:", error)
+        # return None
+
+    print('distance_with_course : ', distance_with_course, 'difference: ',
+    self.waypoint_distance_with_course - self.waypoint_distance)  # Test
+    # return
+
+
 
 
 def whentack():
Index: true_mag.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- true_mag.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ true_mag.py	(revision )
@@ -6,12 +6,7 @@
 from collections import deque
 from math import radians as radian, degrees
 import geomag
-
-# MINAVGMAX = [0.0, 0.0, 0.0]
-# CONVERSION = {'imperial': 2.2369363,
-# 'metric': 3.6,
-#               'nautical': 1.9438445}  # multiplication factors from m/s to units(hour)
-
+course = {}
 CARDINAL = ((011.25, 'N'), (033.75, 'NNE'), (056.25, 'NE'), (078.75, 'ENE'),
             (101.25, 'E'), (123.75, 'ESE'), (146.25, 'SE'), (168.75, 'SSE'),
             (191.25, 'S'), (213.75, 'SSW'), (236.25, 'SW'), (258.75, 'WSW'),
@@ -19,6 +14,28 @@
             (360.00, 'N'))
 
 
+def magdec(lat, lon):
+    """
+    current magnetic declination for location
+    Arguments:
+        :param lat: (float) Latitude
+        :param lon: (float) Longitude
+    Returns:
+        mag_dec: (dict) 'degrees': (float) Degrees Magnetic Declination
+                        'radians': (float) Magnetic Declination in Radians
+            mag_dec = {'degrees': 12.307940565271721, 'radians': 0.2148140870037636}
+
+    """
+    try:
+        mag_dec = {'degrees': geomag.declination(lat, lon)}
+        mag_dec['radians'] = radian(mag_dec['degrees'])  # radians
+        return mag_dec
+
+    except Exception as error:
+        print('Magnetic Declination is sick: ', error)
+        return None
+
+
 def magnetic_course(cog, mag_dec):
     """Course True and Magnetic with Cardinal points
     Arguments:
@@ -27,38 +44,17 @@
         :return:
             course (dict):  'true': (degree, cardinal), as (float, string) tuple
                             'magnetic': (degree, cardinal), as (float, string) tuple
+                course = {'true': (210, 'SSW'), 'magnetic': (222.34567, 'SW')}
     """
+    global course
     course = {'true': cog}
 
     course['magnetic'] = course['true'] + mag_dec
 
-    for key, value in course.items():
-        cardinal_index = (value + 11.25) // 22.5
-        cardinal_index = int(cardinal_index)
-        __, direction = CARDINAL[cardinal_index]
+    for key, value in course.items():  # magnetic or true
+        _index = (value + 11.25) // 22.5
+        _index = int(_index)
+        _, direction = CARDINAL[_index]
         course[key] = value, direction
     return course
 
-
-def magdec(lat, lon):
-    """
-    Magnetic Declination to write magdec to settings
-    Called with every configuration file write and every 24 hours of continous operation
-    :param lat:
-    :param lon:
-    """
-    try:
-        mag_dec = {'degrees': geomag.declination(lat, lon)}
-        mag_dec['radians'] = radian(mag_dec['degrees'])  # radians
-        return mag_dec
-
-    except Exception as error:
-        print('Magnetic Declination is sick: ', error)
-        return None
-
-        # >> > sog = {'meters': 12.317749248906763}
-        # >> > cog = {'true': 2.0197213650119394, 'radians': 0.035250787792332546}
-        # >> > minmax['low'] = sog
-        # >> > minmax
-        # {'low': {'meters': 12.317749248906763}}
-        # >> >
Index: gps.py
===================================================================
--- gps.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ gps.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
@@ -1,385 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#
-# This file is Copyright (c) 2010 by the GPSD project
-# BSD terms apply: see the file COPYING in the distribution root for details.
-#
-# gps.py -- Python interface to GPSD.
-#
-# This interface has a lot of historical cruft in it related to old
-# protocol, and was modeled on the C interface. It won't be thrown
-# away, but it's likely to be deprecated in favor of something more
-# Pythonic.
-#
-# The JSON parts of this (which will be reused by any new interface)
-# now live in a different module.
-###############
-#
-# This file was modified by Moe Feb, 2014, as noted.
-# It lives /usr/lib/python2.7/dist-packages/gps/
-#
-#
-from client import *
-from misc import isotime
-
-NaN = float('nan')
-
-
-def isnan(x): return str(x) == None  # 'nan'
-
-# Don't hand-hack this list, it's generated.
-ONLINE_SET = (1 << 1)
-TIME_SET = (1 << 2)
-TIMERR_SET = (1 << 3)
-LATLON_SET = (1 << 4)
-ALTITUDE_SET = (1 << 5)
-SPEED_SET = (1 << 6)
-TRACK_SET = (1 << 7)
-CLIMB_SET = (1 << 8)
-STATUS_SET = (1 << 9)
-MODE_SET = (1 << 10)
-DOP_SET = (1 << 11)
-HERR_SET = (1 << 12)
-VERR_SET = (1 << 13)
-ATTITUDE_SET = (1 << 14)
-SATELLITE_SET = (1 << 15)
-SPEEDERR_SET = (1 << 16)
-TRACKERR_SET = (1 << 17)
-CLIMBERR_SET = (1 << 18)
-DEVICE_SET = (1 << 19)
-DEVICELIST_SET = (1 << 20)
-DEVICEID_SET = (1 << 21)
-RTCM2_SET = (1 << 22)
-RTCM3_SET = (1 << 23)
-AIS_SET = (1 << 24)
-PACKET_SET = (1 << 25)
-SUBFRAME_SET = (1 << 26)
-GST_SET = (1 << 27)
-VERSION_SET = (1 << 28)
-POLICY_SET = (1 << 29)
-ERROR_SET = (1 << 30)
-UNION_SET = (RTCM2_SET | RTCM3_SET | SUBFRAME_SET | AIS_SET | VERSION_SET | DEVICELIST_SET | ERROR_SET | GST_SET)
-STATUS_NO_FIX = 0
-STATUS_FIX = 1
-STATUS_DGPS_FIX = 2
-MODE_NO_FIX = 1
-MODE_2D = 2
-MODE_3D = 3
-MAXCHANNELS = 20
-SIGNAL_STRENGTH_UNKNOWN = NaN
-
-WATCH_NEWSTYLE = 0x010000  # force JSON streaming
-WATCH_OLDSTYLE = 0x020000  # force old-style streaming
-
-
-class gpsfix:
-    def __init__(self):
-        self.mode = MODE_NO_FIX
-        self.time = None  # NaN
-        self.ept = NaN
-        self.latitude = self.longitude = None  # 0.0
-        self.epx = NaN
-        self.epy = NaN
-        self.altitude = NaN  # Meters
-        self.epv = NaN
-        self.track = None  # NaN            # Degrees from true north
-        self.speed = None  # NaN             # Knots
-        self.climb = NaN  # Meters per second
-        self.epd = NaN
-        self.eps = NaN
-        self.epc = NaN
-
-
-class gpsdata:
-    "Position, track, velocity and status information returned by a GPS."
-
-    class satellite:
-        def __init__(self, PRN, elevation, azimuth, ss, used=None):
-            self.PRN = PRN
-            self.elevation = elevation
-            self.azimuth = azimuth
-            self.ss = ss
-            self.used = used
-
-        def __repr__(self):
-            return "PRN: %3d  E: %3d  Az: %3d  Ss: %3d  Used: %s" % (
-                self.PRN, self.elevation, self.azimuth, self.ss, "ny"[self.used]
-            )
-
-    def __init__(self):
-        # Initialize all data members
-        self.online = 0  # NZ if GPS on, zero if not
-
-        self.valid = 0
-        self.fix = gpsfix()
-
-        self.status = STATUS_NO_FIX
-        self.utc = ""
-
-        self.satellites_used = 0  # Satellites used in last fix
-        self.xdop = self.ydop = self.vdop = self.tdop = 0
-        self.pdop = self.hdop = self.gdop = 0.0
-
-        self.epe = 0.0
-
-        self.satellites = []  # satellite objects in view
-
-        self.gps_id = None
-        self.driver_mode = 0
-        self.baudrate = 0
-        self.stopbits = 0
-        self.cycle = 0
-        self.mincycle = 0
-        self.device = None
-        self.devices = []
-
-        self.version = None
-
-    def __repr__(self):
-        st = "Time:     %s (%s)\n" % (self.utc, self.fix.time)
-        st += "Lat/Lon:  %f %f\n" % (self.fix.latitude, self.fix.longitude)
-        if isnan(self.fix.altitude):
-            st += "Altitude: ?\n"
-        else:
-            st += "Altitude: %f\n" % (self.fix.altitude)
-        if isnan(self.fix.speed):
-            st += "Speed:    ?\n"
-        else:
-            st += "Speed:    %f\n" % (self.fix.speed)
-        if isnan(self.fix.track):
-            st += "Track:    ?\n"
-        else:
-            st += "Track:    %f\n" % (self.fix.track)
-        st += "Status:   STATUS_%s\n" % ("NO_FIX", "FIX", "DGPS_FIX")[self.status]
-        st += "Mode:     MODE_%s\n" % ("ZERO", "NO_FIX", "2D", "3D")[self.fix.mode]
-        st += "Quality:  %d p=%2.2f h=%2.2f v=%2.2f t=%2.2f g=%2.2f\n" % \
-              (self.satellites_used, self.pdop, self.hdop, self.vdop, self.tdop, self.gdop)
-        st += "Y: %s satellites in view:\n" % len(self.satellites)
-        for sat in self.satellites:
-            st += "    %r\n" % sat
-        return st
-
-
-class gps(gpsdata, gpsjson):
-    "Client interface to a running gpsd instance."
-
-    def __init__(self, host="127.0.0.1", port=GPSD_PORT, verbose=0, mode=0):
-        gpscommon.__init__(self, host, port, verbose)
-        gpsdata.__init__(self)
-        self.newstyle = False
-        if mode:
-            self.stream(mode)
-
-    def __oldstyle_unpack(self, buf):
-        # unpack a daemon response into the gps instance members
-        self.fix.time = 0.0
-        fields = buf.strip().split(",")
-        if fields[0] == "GPSD":
-            for field in fields[1:]:
-                if not field or field[1] != '=':
-                    continue
-                cmd = field[0].upper()
-                data = field[2:]
-                if data[0] == "?":
-                    continue
-                if cmd == 'F':
-                    self.device = data
-                elif cmd == 'I':
-                    self.gps_id = data
-                elif cmd == 'O':
-                    fields = data.split()
-                    if fields[0] == '?':
-                        self.fix.mode = MODE_NO_FIX
-                    else:
-                        def default(i, vbit=0, cnv=float):
-                            if fields[i] == '?':
-                                return NaN
-                            else:
-                                try:
-                                    value = cnv(fields[i])
-                                except ValueError:
-                                    return NaN
-                                self.valid |= vbit
-                                return value
-
-                        # clear all valid bits that might be set again below
-                        self.valid &= ~(
-                            TIME_SET | TIMERR_SET | LATLON_SET | ALTITUDE_SET |
-                            HERR_SET | VERR_SET | TRACK_SET | SPEED_SET |
-                            CLIMB_SET | SPEEDERR_SET | CLIMBERR_SET | MODE_SET
-                        )
-                        self.utc = fields[1]
-                        self.fix.time = default(1, TIME_SET)
-                        if not isnan(self.fix.time):
-                            self.utc = isotime(self.fix.time)
-                        self.fix.ept = default(2, TIMERR_SET)
-                        self.fix.latitude = default(3, LATLON_SET)
-                        self.fix.longitude = default(4)
-                        self.fix.altitude = default(5, ALTITUDE_SET)
-                        self.fix.epx = self.epy = default(6, HERR_SET)
-                        self.fix.epv = default(7, VERR_SET)
-                        self.fix.track = default(8, TRACK_SET)
-                        self.fix.speed = default(9, SPEED_SET)
-                        self.fix.climb = default(10, CLIMB_SET)
-                        self.fix.epd = default(11)
-                        self.fix.eps = default(12, SPEEDERR_SET)
-                        self.fix.epc = default(13, CLIMBERR_SET)
-                        if len(fields) > 14:
-                            self.fix.mode = default(14, MODE_SET, int)
-                        else:
-                            if self.valid & ALTITUDE_SET:
-                                self.fix.mode = MODE_2D
-                            else:
-                                self.fix.mode = MODE_3D
-                            self.valid |= MODE_SET
-                elif cmd == 'X':
-                    self.online = float(data)
-                    self.valid |= ONLINE_SET
-                elif cmd == 'Y':
-                    satellites = data.split(":")
-                    prefix = satellites.pop(0).split()
-                    d1 = int(prefix.pop())
-                    newsats = []
-                    for i in range(d1):
-                        newsats.append(gps.satellite(*map(int, satellites[i].split())))
-                    self.satellites = newsats
-                    self.valid |= SATELLITE_SET
-
-    def __oldstyle_shim(self):
-        # The rest is backwards compatibility for the old interface
-        def default(k, dflt, vbit=0):
-            if k not in self.data.keys():
-                return dflt
-            else:
-                self.valid |= vbit
-                return self.data[k]
-
-        if self.data.get("class") == "VERSION":
-            self.version = self.data
-        elif self.data.get("class") == "DEVICE":
-            self.valid = ONLINE_SET | DEVICE_SET
-            self.path = self.data["path"]
-            self.activated = default("activated", None)
-            driver = default("driver", None, DEVICEID_SET)
-            subtype = default("subtype", None, DEVICEID_SET)
-            self.gps_id = driver
-            if subtype:
-                self.gps_id += " " + subtype
-            self.driver_mode = default("native", 0)
-            self.baudrate = default("bps", 0)
-            self.serialmode = default("serialmode", "8N1")
-            self.cycle = default("cycle", NaN)
-            self.mincycle = default("mincycle", NaN)
-        elif self.data.get("class") == "TPV":
-            self.valid = ONLINE_SET
-            self.utc = default("time", None, TIME_SET)
-            if self.utc is not None:
-                # Time can be either Unix time as a float or an ISO8601 string
-                if type(self.fix.time) == type(0.0):
-                    self.fix.time = self.utc
-                else:
-                    self.fix.time = isotime(self.utc.encode("ascii"))
-            self.fix.ept = default("ept", NaN, TIMERR_SET)
-            self.fix.latitude = default("lat", None, LATLON_SET)
-            self.fix.longitude = default("lon", None)
-            self.fix.altitude = default("alt", NaN, ALTITUDE_SET)
-            self.fix.epx = default("epx", NaN, HERR_SET)
-            self.fix.epy = default("epy", NaN, HERR_SET)
-            self.fix.epv = default("epv", NaN, VERR_SET)
-            self.fix.track = default("track", None, TRACK_SET)
-            self.fix.speed = default("speed", None, SPEED_SET)
-            self.fix.climb = default("climb", NaN, CLIMB_SET)
-            self.fix.epd = default("epd", NaN)
-            self.fix.eps = default("eps", NaN, SPEEDERR_SET)
-            self.fix.epc = default("epc", NaN, CLIMBERR_SET)
-            self.fix.mode = default("mode", 0, MODE_SET)
-        elif self.data.get("class") == "SKY":
-            for attrp in ("x", "y", "v", "h", "p", "g"):
-                setattr(self, attrp + "dop", default(attrp + "dop", NaN, DOP_SET))
-            if "satellites" in self.data.keys():
-                self.satellites = []
-                for sat in self.data['satellites']:
-                    self.satellites.append(
-                        gps.satellite(PRN=sat['PRN'], elevation=sat['el'], azimuth=sat['az'], ss=sat['ss'],
-                                      used=sat['used']))
-            self.satellites_used = 0
-            for sat in self.satellites:
-                if sat.used:
-                    self.satellites_used += 1
-            self.valid = ONLINE_SET | SATELLITE_SET
-
-    def read(self):
-        "Read and interpret data from the daemon."
-        status = gpscommon.read(self)
-        if status <= 0:
-            return status
-        if self.response.startswith("{") and self.response.endswith("}\r\n"):
-            self.unpack(self.response)
-            self.__oldstyle_shim()
-            self.newstyle = True
-            self.valid |= PACKET_SET
-        elif self.response.startswith("GPSD"):
-            self.__oldstyle_unpack(self.response)
-            self.valid |= PACKET_SET
-        return 0
-
-    def next(self):
-        if self.read() == -1:
-            raise StopIteration
-        if hasattr(self, "data"):
-            return self.data
-        else:
-            return self.response
-
-    def stream(self, flags=0, devpath=None):
-        "Ask gpsd to stream reports at your client."
-        if (flags & (WATCH_JSON | WATCH_OLDSTYLE | WATCH_NMEA | WATCH_RAW)) == 0:
-            flags |= WATCH_JSON
-        if flags & WATCH_DISABLE:
-            if flags & WATCH_OLDSTYLE:
-                arg = "w-"
-                if flags & WATCH_NMEA:
-                    arg += 'r-'
-                    return self.send(arg)
-            else:
-                gpsjson.stream(self, ~flags, devpath)
-        else:  # flags & WATCH_ENABLE:
-            if flags & WATCH_OLDSTYLE:
-                arg = 'w+'
-                if (flags & WATCH_NMEA):
-                    arg += 'r+'
-                    return self.send(arg)
-            else:
-                gpsjson.stream(self, flags, devpath)
-
-
-if __name__ == '__main__':
-    import getopt, sys
-
-    (options, arguments) = getopt.getopt(sys.argv[1:], "v")
-    streaming = False
-    verbose = False
-    for (switch, val) in options:
-        if switch == '-v':
-            verbose = True
-    if len(arguments) > 2:
-        print 'Usage: gps.py [-v] [host [port]]'
-        sys.exit(1)
-
-    opts = {"verbose": verbose}
-    if len(arguments) > 0:
-        opts["host"] = arguments[0]
-    if len(arguments) > 1:
-        opts["port"] = arguments[1]
-
-    session = gps(**opts)
-    session.stream(WATCH_ENABLE)
-    try:
-        for report in session:
-            print report
-    except KeyboardInterrupt:
-        # Avoid garble on ^C
-        print ""
-
-# gps.py ends here
-
Index: control.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- control.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ control.py	(revision )
@@ -1,7 +1,9 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+
+
 """Create and read user configuration file and settings and periodic functions"""
-import ConfigParser
+import configparser
 import os
 from datetime import timedelta
 from time import time
@@ -97,8 +99,8 @@
         # datetime.strptime('2014-04-25', '%Y-%m-%d')  # dummy call  http://bugs.python.org/issue7980 Doesn't work here.
 
         if os.path.isfile(self.configuration_file):
-            print 'reading configuration from: ', self.configuration_file
-            configuration = ConfigParser.RawConfigParser()
+            print('reading configuration from: ', self.configuration_file)
+            configuration = configparser.RawConfigParser()
             configuration.read(self.configuration_file)
 
             try:
@@ -172,22 +174,11 @@
                 #                         for s in self.nightcolor[-1].split(','))
 
             except ValueError or IOError as error:
-                print 'The read configuration error is:', error
+                print('The read configuration error is:', error)
                 os.makedirs(self.home_directory + '/.wadda/')
         else:
-            print '-- writing default configuration file --'
+            print('-- writing default configuration file --')
             self.write_configuration()
-                #
-                # self.write_configuration()
-                # retries = 0
-                # while IOError and retries < 2:
-                #     try:
-                #         self.read_configuration()
-                #     except IOError:
-                #         print 'Error recovery re-read of the configuration file'
-                #         return
-                #     retries += 1
-                # sys.exit('Something is really stuffed.\nCheck ~/.wadda')
         return
 
     def write_configuration(self):
@@ -199,8 +190,8 @@
         # timezone()
 
         try:
-            print 'writing configuration to: ', self.configuration_file  # TODO: Needs exceptions
-            configuration = ConfigParser.RawConfigParser()
+            print('writing configuration to: ', self.configuration_file)  # TODO: Needs exceptions
+            configuration = configparser.RawConfigParser()
 
             # NxGPS
             configuration.add_section('NxGPS')
@@ -276,24 +267,17 @@
             # TODO: find file location
             os.makedirs(self.home_directory + '/.wadda/')
             os.makedirs(self.waypoint_directory)
-            # self.write_configuration()
-            # retries = 0
-            # if IOError and retries < 2:
-            #     try:
-            #         self.write_configuration()
-            #     except IOError:
-            #         print 'Error recovery write of the configuration file'
-            #         return
-            #     retries += 1
-            # sys.exit('Something is really stuffed.\nCheck ~/.wadda')
+
         return
 
 settings = Settings()
 
 
-class Units():
-
+class Units(object):
     # Units per meter
+    def __init__(self):
+        pass
+
     DISTANCE = {
         'NM': 0.0005399568,
         'Miles': 0.00062137119,
@@ -308,9 +292,10 @@
         (191.25, 'S'), (213.75, 'SSW'), (236.25, 'SW'), (258.75, 'WSW'),
         (281.25, 'W'), (303.75, 'WNW'), (326.25, 'NW'), (348.75, 'NNW'),
         (360, 'N')
+
     )
     # CARD = {011.25: 'N', 033.75: 'NNE', 056.25: 'NE', 078.75: 'ENE',
-    #         101.25: 'E', 123.75: 'ESE', 146.25: 'SE', 168.75: 'SSE',
+    # 101.25: 'E', 123.75: 'ESE', 146.25: 'SE', 168.75: 'SSE',
     #         191.25: 'S', 213.75: 'SSW', 236.25: 'SW', 258.75: 'WSW',
     #         281.25: 'W', 303.75: 'WNW', 326.25: 'NW', 348.75: 'NNW',
     #         360: 'N'}
Index: odometer.py
===================================================================
--- odometer.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ odometer.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
@@ -1,132 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-""" odometer.py
-    A collection of distance and waypoint functions (2) for the NxGPS Project:
-    Getting the most out of a $30 gps, for Navigatrix (http://navigatrix.net)
-    NxGPS project repository is (https://github.com/wadda/NxGPS)
-"""
-from pyproj import Geod
-from cmath import asin, sin
-import math
-# from math import radians, degrees
-# import gps3
-
-conversion = {'nautical': 1852.0, 'imperial': 1609.344, 'metric': 1000.0, 'meters': 1.0}
-
-
-class Odometer(object):
-    """Odometer is a wrapper around pyproj.Geod distance calculations"""
-
-    def __init__(self):
-        self.bearing_to = None
-        self.bearing_fro = None
-        self.distance = {}
-
-    def do_to_fro_distance(self, lat1, lon1, lat2, lon2, units='meters'):
-        """lat lon from point A and point B, returns True North
-        bearings 'to', A-B(1-2), and 'fro', B-A (2-1) and distance in always
-        fashionable meters with optional nautical, imperial, or (kilo)metric"""
-        bearing_to = bearing_fro = self.distance['meters'] = None
-        try:
-            geoid = Geod(ellps='WGS84')
-            bearing_to, bearing_fro, self.distance['meters'] = geoid.inv(lon1, lat1, lon2, lat2)
-
-        except Exception as error:
-            print("Can't calculate to/fro because:", error)
-
-        finally:
-            if units not in 'meters':
-                self.distance[units] = self.distance['meters'] / conversion[units]
-
-            self.bearing_to = bearing_to % 360
-            self.bearing_fro = bearing_fro % 360
-
-        return self.bearing_to, self.bearing_fro, self.distance
-
-
-odometer = Odometer()
-
-
-class Waypoints(object):
-    def __init__(self):
-        self.startpoint_lat = None
-        self.startpoint_lon = None
-        self.a2b_radians = None
-        self.trip_distance = {}
-
-    def do_crosstrack(self, current_lat, current_lon, start_lat=None, start_lon=None,
-                      end_lat=None, end_lon=None, units='meters'):
-        """
-        return crosstrack distance from current position, and last set track or
-        return crosstrack distance from current position, start, and end positions
-
-        Formula from:
-        http: // williams.best.vwh.net / avform.htm  # XTE
-
-        """
-        default_lat = -15.560615  # Apataki Carenage
-        default_lon = -146.241122  # Apataki Carenage
-        default_a2b_radians = 4.2538533202126025  # bearing in radians Apataki to Kaputar
-        earth_radius = 6371009.0  # meters...It's a mean radius, but nice enough.
-        crosstrack_distance = {}
-
-        try:
-            if all([start_lon, start_lon, end_lat, end_lon]):  # both start and end shall start and end together.
-                # A to B
-                a2b_bearing, _, _ = odometer.do_to_fro_distance(start_lat, start_lon, end_lat, end_lon)
-                self.a2b_radians = math.radians(a2b_bearing)
-                self.startpoint_lat = start_lat
-                self.startpoint_lon = start_lon
-                # A to C
-            if not any([start_lat, start_lon, end_lat, end_lon]):
-                if not self.startpoint_lat:  # one is enough, or one is not enough, depending on perspective
-                    self.startpoint_lat = default_lat
-                    self.startpoint_lon = default_lon
-                    self.a2b_radians = default_a2b_radians
-                start_lat = self.startpoint_lat
-                start_lon = self.startpoint_lon
-
-            bearing_to, _, distance = odometer.do_to_fro_distance(start_lat, start_lon, current_lat, current_lon)
-            a2c_radians = math.radians(bearing_to)
-            self.trip_distance = distance
-            # Calculations in radians, output in complex numbers {'meters': (281.8893996162284+0j)
-            crosstrack_distance['meters'] = (asin(sin(distance['meters']) * sin(a2c_radians - self.a2b_radians))
-                                             * earth_radius)
-        except Exception as error:
-            print('Can\'t calculate crosstrack because: ', error)
-
-        finally:
-            if units not in 'meters':
-                crosstrack_distance[units] = crosstrack_distance['meters'] / conversion[units]
-            print('Positive should mean right of course, negative means left with the other choice.')
-
-            for k, v in crosstrack_distance.items():
-                print(k, ":", v.real)  # extract 'real' number
-
-            print("Scabed on xtrk trip distance:", self.trip_distance)
-
-            print('Real and imaginary in complex number:\n')
-
-        return crosstrack_distance
-
-
-waypoints = Waypoints()
-
-
-class BestSenario(object):
-    """Speculative calculations for conjecture and BS to"""
-    # WIP
-    pass
-
-    def eta(self):
-        pass
-
-    def vmg(self):
-        pass
-
-    def whentack(self):
-        pass
-
-    def shortest(self):
-        pass
-
Index: old_odometer.py
===================================================================
--- old_odometer.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ old_odometer.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
@@ -1,149 +0,0 @@
-# -*- coding: utf-8 -*-
-
-"""Module that uses Starting Position, Current Position
-and pre-calculated bearing from SP to Waypoint"""
-from cmath import asin, sin
-from math import radians
-from pubsub import pub
-from pyproj import Geod
-import gps3
-import control
-
-settings = control.settings
-units = control.units
-
-
-class Odometer(object):
-    """Odometer and Cross Track Error"""
-
-    def __init__(self):
-        self.odometer_bearing = None
-        self.odometer_distance = None
-
-    def do_odometer(self, lat, lon):
-        """Start Point to current position distance"""
-        if not settings.show_odometer and not settings.show_crosstrack:
-            return
-
-        if isinstance(gps3.Fix.TPV['lat'], str):
-            return
-
-        if settings.startpoint_lat is None:
-            self.reset_startpoint()  # Does anything, or just get in the way?
-            return
-        try:
-            geoid = Geod(ellps='WGS84')
-            startpoint_lat = settings.startpoint_lat
-            startpoint_lon = settings.startpoint_lon
-            self.odometer_bearing, __, self.odometer_distance = geoid.inv(startpoint_lon, startpoint_lat, lon, lat)
-
-        except Exception as error:
-            print("Can't calculate odometer: ", error)
-
-        finally:
-            if settings.show_odometer:
-                odo_distance = self.odometer_distance
-                odo_distance *= units.DISTANCE[settings.distance_units]
-                pretty_odometer = '{0:.2f} {1}'.format(odo_distance, settings.distance_units)
-
-                pub.sendMessage('show_odometer', show_odometer=pretty_odometer)
-                print('Odometer:', pretty_odometer)
-
-            self.do_crosstrack()  # Call crosstrack()
-            return  # TODO: Add unsubscribe
-
-    def do_crosstrack(self):
-        """
-        http://williams.best.vwh.net/avform.htm#XTE
-
-        Cross track error:
-
-        Suppose you are proceeding on a great circle route from
-        A to B (course =crs_AB) and end up at D, perhaps off course.
-        (We presume that A is ot a pole!) You can calculate the
-        course from A to D (crs_AD) and the original_distance from A to
-        D (dist_AD) using the formulae above. In terms of these the cross track
-        error, XTD, (distance off course) is given by
-         crosstrack_distance = asin(sin(distancetravelled) * sin(coursetaken - courseintended))
-         XTD =asin(sin(dist_AD)*sin(crs_AD-crs_AB))
-
-        (positive XTD means right of course, negative means left)
-        (If the point A is the N. or S. Pole replace crs_AD-crs_AB with
-        lon_D-lon_B or lon_B-lon_D, respectively.)
-
-        The "along track distance", ATD, the distance from A along the
-        course towards B to the point abeam D is given by:
-
-                 ATD=acos(cos(dist_AD)/cos(XTD))
-
-        For very short distances:
-
-                 ATD=asin(sqrt( (sin(dist_AD))^2 - (sin(XTD))^2 )/cos(XTD))
-
-        is less susceptible to rounding error
-
-        Note that we can also use the above formulae to find the point of
-        closest approach to the point D on the great circle through A and B
-
-        Formula:
-        self.original_distance = 'distance' from StartPoint to Current Position
-        self.original_bearing = 'bearing' from StartPoint to Current Position
-        settings.startpoint_to_waypoint_bearing = 'origc' bearing from StartPoint to Waypoint
-        'earth_radius' is the earth’s radius...it's big.
-
-        crosstrack_distance =asin(sin(original_distance)*sin(bearing - origc)) * earth_radius
-
-        (positive crosstrack_distance  means right of course, negative means left...we hope.)
-        """
-        if not settings.show_crosstrack:
-            return
-
-        if not settings.waypoint_lat:  # Should be unneccessary
-            print('Waypoint has not been set')  # TODO: Open waypoint dialogue
-            return
-
-        if not settings.startpoint_to_waypoint_bearing:
-            return
-
-        if not settings.startpoint_to_waypoint_distance:
-            return
-
-        pretty_crosstrack = None
-        if settings.startpoint_to_waypoint_bearing == float('Inf'):
-            return
-
-        try:
-            startpoint_to_waypoint_bearing = radians(settings.startpoint_to_waypoint_bearing)
-
-            earth_radius = 6371009.0  # meters...It's a mean radius, but nice enough.
-            odobearing = radians(self.odometer_bearing)
-            crosstrack_distance = (asin(sin(settings.startpoint_to_waypoint_distance) * sin(odobearing - startpoint_to_waypoint_bearing)) * earth_radius)
-
-            crosstrack_distance *= 1  # TODO: REPLACE units.DISTANCE[settings.distance_units]
-            pretty_crosstrack = '{0:2.1f} {1}'.format(crosstrack_distance, settings.distance_units)
-            print('-----------')
-            print(startpoint_to_waypoint_bearing)
-            print(odobearing)
-            print(crosstrack_distance)
-            print('mmmmmmmmmmmmm')
-
-        except Exception as error:
-            print('Can\'t calculate crosstrack because: ', error)
-            pretty_crosstrack = 'There be dragons.'
-
-        finally:
-            pub.sendMessage('crosstrack', show_crosstrack=pretty_crosstrack)
-            print('Cross Track: ', pretty_crosstrack)  # Test
-            return
-
-    @staticmethod
-    def reset_startpoint():
-        """set to None and re-fetch"""
-        settings.startpoint_lat = None
-        settings.startpoint_lon = None
-        settings.startpoint_to_waypoint_bearing = None
-        settings.startpoint_to_waypoint_distance = None
-        return
-
-
-odometer = Odometer()
Index: timestatus.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timestatus.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ timestatus.py	(revision )
@@ -1,5 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+
+
 """Time stuff"""
 from time import time
 from datetime import datetime
@@ -43,7 +45,7 @@
             return
         else:
             self.gpstime = dateutil.parser.parse(utc)  # Become datetime object
-            print type(self.today), type(self.gpstime)
+            print(type(self.today), type(self.gpstime))
             if not self.today or self.today <= self.gpstime:  # So we can do this comparison
                 latlon.do_latlon.magdec()  # TODO: Remember to add ui events for this function
                 deltatee = dateutil.tz.tzlocal()
@@ -69,7 +71,7 @@
         if self.gpstime is None:  # Shouldn't ever happen (unnecessary?)
             pretty_time = "No Data"
             pub.sendMessage('show_time', show_time=pretty_time)
-            print 'ND Time: ', pretty_time
+            print('NoData Time: ', pretty_time)
             return
 
         shiptime = self.gpstime
@@ -100,7 +102,7 @@
 
         finally:
             pub.sendMessage('show_time', show_time=pretty_time)
-            print 'Time: ', pretty_time  # Test
+            print('Time: ', pretty_time)  # Test
 
         return
 
@@ -116,7 +118,7 @@
         if self.gpstime is None:  # Shouldn't ever happen...should it.
             pretty_date = "Ooops"
             pub.sendMessage('show_date', show_date=pretty_date)
-            print 'Date: ', pretty_date  # Test
+            print('Date: ', pretty_date)  # Test
             return
 
         shiptime = self.gpstime
@@ -138,12 +140,12 @@
                 pretty_date = shiptime.strftime('%A, %b %d, %Y')
 
         except Exception as error:
-            pretty_date = error
-            print 'Date error :', error
+            pretty_date = "bRo-KeN"
+            print('Date error :', error)
 
         finally:
             pub.sendMessage('show_date', show_date=pretty_date)
-            print 'Date: ', pretty_date
+            print('Date: ', pretty_date)
             return
 
 
@@ -181,7 +183,7 @@
             pretty_sats = '{} of {}'.format(sats_used, sats_inview)
 
         pub.sendMessage('show_quality', show_mode=pretty_mode, show_usedinview=pretty_sats)
-        print 'Quality: ', pretty_mode, 'using', pretty_sats, 'satellites in view'  # Test
+        print('Quality: ', pretty_mode, 'using', pretty_sats, 'satellites in view')  # Test
         return
 
 timestatus = TimeStatus()
@@ -199,6 +201,7 @@
             return
 
         pretty_elapsed = None
+        time_delta = None
         try:
             time_now = time()
             time_delta = time_now - settings.time_beginning
@@ -222,7 +225,7 @@
 
         finally:
             pub.sendMessage('show_elapsed', show_elapsed=pretty_elapsed)
-            print 'Elapsed Time: ', pretty_elapsed, 'timedelta: ', time_delta
+            print('Elapsed Time: ', pretty_elapsed, 'timedelta: ', time_delta)
 
             return
 
@@ -248,3 +251,8 @@
         return
 
 misc = Misc()
+
+    actionList = []
+    for k in gameState.getLegalActions(agentIndex):
+        actionList.append((self.miniMaxHelp(gameState.generateSuccessor(agentIndex, k),
+                                            newDepth, ind)[0], k))
Index: run.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- run.py	(revision 7fc3879c919042fcb11aaad49eaeb9098b37ab5a)
+++ run.py	(revision )
@@ -1,5 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+from __future__ import print_function
+
 __author__ = 'wadda'
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
@@ -7,7 +9,7 @@
 
 import gpsclient
 import latlon
-import odometer
+import old_odometer
 import sogcog
 import timestatus
 import waypoint
@@ -19,11 +21,11 @@
 
 def run():
     """calls instance and runs until it doesn't"""
-    print 'Fired up------------------------'
+    print('Fired up------------------------')
     try:
         settings.read_configuration()
     except Exception as error:
-        print 'this error in run.py: ', error
+        print('this error in run.py: ', error)
         settings.write_configuration()
 
     while gpsclient.data.running:
@@ -36,13 +38,13 @@
 
     # Ctrl C
     except KeyboardInterrupt:
-        # print 'Run error is:', error
-        print "User cancelled"
+        # print('Run error is:', error
+        print("User cancelled")
 
     finally:
-        print "Stopping gps client"
+        print("Stopping gps client")
         gpsclient.data.stopclient()
         # wait for the tread to finish
         gpsclient.data.join()
 
-        print "Done"
+        print("Done")
